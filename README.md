# project_cpp-_postgres
# Выполнение тестовго задания с использованием языка С++, PostgreSQL и libpqxx библиотеки.
# Общие требования:
- Написать приложение, которое будет запускаться из консоли с параметрами. Первый параметр, передаваемый при запуке, выбирает режим работы приложения соответствующий пункту задания.
# Интсрументы
- С++
- PostgreSQL
- библиотека libpqxx
- makefile

# Компиляция
make main

# Небольшое описание

У нас есть два класса: 
 - класс class my_application, который создан для подключения и работы с базой данных
 - класс class employee, который описывает работника. По умолчания имя базы данных, которую нужно будет создать передается в конструктор класса my_application. Имя базы данных "emp_db".
   
По умолчанию в PostgreSQL для пользователя posgtres имеется три базы данных: 
 - postgress
 - template0
 - template1.
   
Мы сначала подключимся к одной из них, а именно к базе данных dbname=postgres, это поле представлено в классе my_application: const char* default_database = "dbname=postgres user=postgres password=db1996 host=localhost port = 5432". Порт 5432 используется по умолчанию для PostgreSQL. 

<img width="1861" height="574" alt="Screenshot from 2025-07-25 11-26-46" src="https://github.com/user-attachments/assets/c092e16f-74d4-4621-bc60-2103ee20c0a7" />


# Решение
# 1 Пунтк. Создание таблицы с полями справочника сотрудников, представляющими "Фамилию Имя Отчество", "дату рождения", "пол".

Пример запуска ./main 1

# Описание работы.

Что происходит во время запуска приложения с параметром 1.

- Создается объект класса **my_application my_application app("emp_db")** и вызывается конструктор. Имя базы данных - **emp_db**.
- Внутри конструктора происходит следующее: Подключаемся к базе данных **dbname=postgres**, с помощью объекта **connection(pqxx::connection)**, который на вход принимает имя базы данных **dbname=postgres**.
- После этого вызываем метод **check_database_exsistence(c, database_name)**. Принимает на вход объект типа **connection(pqxx::connection)** и имя базы данных, которую мы хотим создать**("emp_db")**, с целью проверить не существует ли уже база данных с таким именем.
  
  Внутри метода создаем нетранзакционный объект **pqxx::nontransaction ntr(c)**. Он нам нужен так как если окажется, что такой базы данных с таким именем нет, её нужно будет создать выполнив SQL запрос **(CREATE", " DATABASE")**, который можно выполнять только в нетранзацкионном объекте. И так если заданной базы данных не существует, то создаем ее. Метод **generate_string(buffer, "CREATE", " DATABASE", " ", db_name, " ENCODING", " UTF8", " TEMPLATE", " template0;", NULL)** создает строковое представление SQL запроса, и записывает его в переменную **buffer**. Выполняем запрос и создаем базу данных **r = ntr.exec(buffer);** Возвращает объект типа **pqxx::result**.

Далее так как мы передали аргументом - 1. Вызывается метод **app.run_app(argv[1][0] - '0', NULL, NULL, NULL)**, который принимает номер режима. В run_app создаем объект типа **connection(pqxx::connection)** и подключаемся к нашей базе данных **"emp_db"**, после этого создаем объект типа транзакция для выполнения SQL запросов pqxx::work tr(c). Выполняем SQL запрос и создаем таблицу, **pqxx::result r = tr.exec(create_table_sql_query())**. Метод **create_table_sql_query** - возвращает SQL запрос в виде строки.

**Как выглядит SQL запрос для создания таблицы:**
const char* sql_query = "CREATE TABLE IF NOT EXISTS employee (" "emp_id SERIAL PRIMARY KEY," "first_name VARCHAR(80) NOT NULL," "paternal_name VARCHAR(80) NOT NULL," "last_name VARCHAR(80) NOT NULL," "birth_date DATE NOT NULL,"	"sex VARCHAR(80) NOT NULL"");";

emp_id - ключ, first_name(Имя) длиной в 80 символов, не может принимать значение NULL. Дальше отчество, фамилия, дата рождения и пол.

# Итог выполнения
Как посмотерть результат. В терминале вводим команду sudo -u posgtres psql, и после вводим \l, команда покажет все существующие базы данных.

<img width="1820" height="477" alt="Screenshot from 2025-07-25 11-27-52" src="https://github.com/user-attachments/assets/7d1306ef-f3fb-4ea2-8e07-91fb5d35045d" />

Как видим у нас появилась база данных **emp_db**
Теперь посмотрим на таблицу, которую мы создали. Таблица с названием **employee**. В терминале снова запускаем команду sudo -u postgres psql. Затем подключаемся к базе данных **emp_db**, выполняем команду **\c emp_db**. Интерпретатор выдаст сообщение, что мы успешно подключились к базе данных. Теперь распечатаем таблицу **employee**, чтобы увидеть как она выглядит. Запускаем команду **SELECT * FROM employee;**

<img width="1826" height="191" alt="Screenshot from 2025-07-25 11-28-58" src="https://github.com/user-attachments/assets/415689dd-7230-4f71-ab48-455467d02048" />

Как видим мы создали пустую таблицу с полями **emp_id(ключ), имя(first_name), отчество(paternal_name), фамилия(last_name), дата рождения(birth_date), пол(sex).**

# Пунтк 2. Создание записи справочника сотрудников.

**Пример запуска ./main 2 "Ivan Sergeevich Ivanov" "1997-01-12" "Male"**

Для работы с данными создать класс и создавать объекты. При вводе создавать новый объект класса, с введенными пользователем данными.
При генерации строчек в базу создавать объект и его отправлять в базу/формировать строчку для отправки нескольких строк в БД.
У объекта должны быть методы, которые:
- отправляют объект в БД,
- рассчитывают возраст (полных лет).

Для выполнения данного пункта был создан класс **Employee**, со следующими полями и и методами, один высчитывает возраст сотрудника, а другой отправляет объект класса **employee** для записи его в базу данных:
Поля класса **Employee**.
first_name - Имя рабочего
paternal_name - Отчество рабочего
last_name - Фамилия рабочего
birth_date - Дата рождения
sex - пол

Метод void get_employee_age(const char* date, char* abuf) - высчитывает возраст.
Метод void send_to_database(pqxx::work& tr) - отправляет объект.

В функции main вызывается метод **app.run_app(argv[1][0] - '0', argv[2], argv[3], argv[4]).** Первый параметер - это **режим, второй ФИО, третий дата рождения и четвертый пол**. В методе **run_app** создается объект класса **employee**, ему передаются параметры ФИО, Дата рождения, Пол **employee e(arg1, arg2, arg3)**, для инициализации полей. После инициализации, отправляем объект в базу данных вызывая метод **e.send_to_database(tr)**, который принимает объект типа **pqxx::work** для выполнения транзакций. Как работает метод **send_to_database(tr)**:

Создаем в нем объект типа **pqxx::param**, заполняя его поля с помощью метода **append**, в который передаем ФИО, год рождения и пол. Например **p.append(first_name)** и так далее. После этого выполняем SQL запрос вида: **pqxx::result r = tr.exec_params("INSERT INTO employee (first_name, paternal_name, last_name, birth_date, sex) VALUES ($1, $2, $3, $4, $5)", p)**. Где **$1-$5** параметры, которые берутся из объекта **param** и записываются в таблицу **employee**.

Как проверить результат. Снова в терминале запускаем команду, sudo -u postgres psql, получем приглашение интерпретатора, после подключаемся к базе данных \c emp_db, затем команду SELECT * FROM employee, которая выводит нашу таблицу.

<img width="1833" height="310" alt="Screenshot from 2025-07-25 11-31-09" src="https://github.com/user-attachments/assets/b23f0021-197b-435f-a8c1-ab3e34a39c0d" />



# Пункт 3. Вывод всех строк справочника сотрудников, с уникальным значением ФИО+дата, отсортированным по ФИО. Вывести ФИО, Дату рождения, пол, кол-во полных лет.

**Запускаем ./main 3**

В main вызываем функцию **app.run_app(argv[1][0] - '0', NULL, NULL, NULL)**, в функции **run_app** вызываем функцию **print_database(tr)** класса **my_application** и передаем ему объекта типа **pqxx::work** для выполнения SQL запроса вида **pqxx::result r = tr.exec("SELECT first_name, paternal_name, last_name, birth_date, sex FROM employee ORDER BY first_name ASC, paternal_name ASC, last_name ASC;")**. Который выбирает заданные поля из таблицы employee, возвращает объект типа result и дальше все выводим.

Результат:

<img width="1654" height="1116" alt="Screenshot from 2025-07-25 12-34-51" src="https://github.com/user-attachments/assets/043973ec-bec9-4dc9-8e12-a0c255463c53" />


# Пункт 4 Заполнение автоматически 1000000 строк справочника сотрудников. Распределение пола в них должно быть относительно равномерным, начальной буквы ФИО также. Добавить заполнение автоматически 100 строк в которых пол мужской и Фамилия начинается с "F". У класса необходимо создать метод, который пакетно отправляет данные в БД, принимая массив объектов.
Как запускать ./main 4

В функции main вызывается метод **app.run_app(argv[1][0] - '0', NULL, NULL, NULL)**. Создаем массив указателей на объекта класса employee.

- a_employee = (employee**)malloc(sizeof(*a_employee) * lines_to_fill)**, константа **lines_to_fill** означает количество строчек которые нужно сгенерировать.
- После этого вызываем метод **automate_db_fill(a_employee, tr)**, передавая в него массив и объект типа **pqxx::work.**
  
В методе  **automate_db_fill(employee** a_employee, pqxx::work& tr)** мы в цикле for миллион раз вызываем метод **store_object(a_employee, i, tr)**. Метод **store_object**, создает объект типа employee инициализирует его и отправляет для записи его в базу данных. Первые 100 объектов создаются с мужским полом и фаимилией, которая начинается на F. Остальные создаются с рапсредленением.

Результат работы: Снова запускаем команду sudo -u postgres psql, затем подключаемся к базе данных emp_db -> \c emp_db. Дальше выводи поля таблицы employee. SELECT * FROM employee; Первые 100 строк были заполнены автоматически, фамилия начинается с F и пол мужской


<img width="1810" height="1079" alt="Screenshot from 2025-07-25 11-32-31" src="https://github.com/user-attachments/assets/c7b64451-28ca-464f-a715-fd0c364e3282" />


# Пункт 5. 5. Результат выборки из таблицы по критерию: пол мужской, Фамилия начинается с "F". Сделать замер времени выполнения.

Пример запуска приложения:
*./main 5*

Вывод приложения должен содержать время. Заполнить это время в отчете по выполнению тестового задания.

В функции main вызываем метод case 5 : **app.run_app(argv[1][0] - '0', NULL, NULL, NULL)**. В **run_app** вызываем метод **run_query(pqxx::work& tr)**, передаем ему объект типа **pqxx::work tr** для выполнения SQL запроса.

Что происходит в методе.
- Сохраняем текущее время в переменной **start**, после этого выполняем SQL запрос **"SELECT last_name, sex FROM employee WHERE last_name LIKE ('F%') and sex LIKE 'Male%';")** Выбираем фамилию и пол.
- Сохраняем текущее время, в переменной **end** после выполнения запроса. Высчитываем разность и получаем время выполнения запроса.

Результат представлен в секундах. Наш результат 0.00028

<img width="1686" height="39" alt="Screenshot from 2025-07-25 11-35-10" src="https://github.com/user-attachments/assets/568f7dad-9ff6-44a9-a704-20e5e4b2b2b7" />
